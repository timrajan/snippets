 const element = await page.evaluate(() => {
    function deepQuerySelector(root: Document | ShadowRoot, selector: string): Element | null {
      let element = root.querySelector(selector);
      if (element) return element;

      const allElements = root.querySelectorAll('*');
      for (let i = 0; i < allElements.length; i++) {
        const el = allElements[i];
        if (el.shadowRoot) {
          element = deepQuerySelector(el.shadowRoot, selector);
          if (element) return element;
        }
      }
      return null;
    }

    // Now you can use document
    return deepQuerySelector(document, 'button.submit');
  });





import puppeteer, { Browser, Page } from 'puppeteer';

interface StyleExtractionResult {
  elementInfo: {
    tag: string;
    id: string;
    classes: string;
  };
  html: string;
  computedStyles: Record<string, string>;
  inlineStyles: Record<string, string>;
  formattedOutput: string;
}

/**
 * Helper function to convert RGB/RGBA to Hex
 */
function rgbToHex(rgb: string): string {
  // Check if it's already a hex color or other format
  if (!rgb.startsWith('rgb')) {
    return rgb;
  }

  // Extract RGB values
  const match = rgb.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
  if (!match) return rgb;

  const r = parseInt(match[1]);
  const g = parseInt(match[2]);
  const b = parseInt(match[3]);
  const a = match[4] ? parseFloat(match[4]) : null;

  // Convert to hex
  const toHex = (n: number): string => {
    const hex = n.toString(16);
    return hex.length === 1 ? '0' + hex : hex;
  };

  const hexColor = `#${toHex(r)}${toHex(g)}${toHex(b)}`;

  // If there's alpha, include it
  if (a !== null && a < 1) {
    const alphaHex = toHex(Math.round(a * 255));
    return `${hexColor}${alphaHex} (${Math.round(a * 100)}% opacity)`;
  }

  return hexColor;
}

/**
 * Extract all style information from an element on a webpage
 * @param url - The URL of the webpage
 * @param selector - CSS selector to target the element (e.g., 'div.header', '#main-content')
 * @param options - Optional configuration
 * @returns Style extraction result
 */
export async function extractElementStyles(
  url: string,
  selector: string,
  options?: {
    headless?: boolean;
    outputFile?: string;
    screenshotPath?: string;
    pdfPath?: string;
    selective?: boolean;
    styleListFile?: string;
    deepSearch?: boolean;
  }
): Promise<StyleExtractionResult> {
  const browser: Browser = await puppeteer.launch({
    headless: options?.headless ?? true,
  });

  try {
    const page: Page = await browser.newPage();
    await page.goto(url, { waitUntil: 'networkidle2' });

    // Wait for the element to be present (skip for deep search as it will search in shadow DOM)
    if (!options?.deepSearch) {
      await page.waitForSelector(selector, { timeout: 10000 });
    } else {
      console.log('ðŸ” Deep search enabled - searching through shadow DOM...');
      // Give page time to render
      await new Promise(resolve => setTimeout(resolve, 2000));
    }

    // Read selective style list if needed
    let selectiveStyles: string[] | null = null;
    if (options?.selective) {
      const fs = await import('fs/promises');
      const styleListPath = options.styleListFile || 'getstyles.txt';
      try {
        const content = await fs.readFile(styleListPath, 'utf-8');
        selectiveStyles = content
          .split('\n')
          .map(line => line.trim())
          .filter(line => line.length > 0 && !line.startsWith('#'));
        console.log(`âœ… Loaded ${selectiveStyles.length} styles from ${styleListPath}`);
      } catch (err) {
        console.warn(`âš ï¸  Could not read ${styleListPath}, extracting all styles`);
        selectiveStyles = null;
      }
    }

    // Extract styles from the page
    const result = await page.evaluate((sel, rgbToHexStr, styleFilter, useDeepSearch) => {
      // Recreate the rgbToHex function in the browser context
      const rgbToHexFunc = new Function('return ' + rgbToHexStr)();

      // Deep search function to find elements in shadow DOM
      function deepQuerySelector(root: Document | ShadowRoot, selector: string): Element | null {
        // Try to find in current root
        let element = root.querySelector(selector);
        if (element) return element;

        // Search in all shadow roots recursively
        const allElements = root.querySelectorAll('*');
        for (let i = 0; i < allElements.length; i++) {
          const el = allElements[i];
          if (el.shadowRoot) {
            element = deepQuerySelector(el.shadowRoot, selector);
            if (element) return element;
          }
        }

        return null;
      }

      const element = useDeepSearch
        ? deepQuerySelector(document, sel)
        : document.querySelector(sel);

      if (!element) {
        throw new Error(`Element not found: ${sel}${useDeepSearch ? ' (searched in shadow DOM)' : ''}`);
      }

      const output: string[] = [];

      // Basic element information
      output.push('=== ELEMENT INFORMATION ===');
      output.push(`Tag: ${element.tagName}`);
      output.push(`ID: ${element.id || 'none'}`);
      output.push(`Classes: ${element.className || 'none'}`);
      output.push('');

      // HTML
      output.push('=== HTML ===');
      output.push(element.outerHTML);
      output.push('');

      // Computed styles
      output.push('=== COMPUTED STYLES ===');
      const computedStyles = window.getComputedStyle(element);
      const computedStylesObj: Record<string, string> = {};

      // Filter styles if selective mode is enabled
      const shouldIncludeStyle = (prop: string) => {
        if (!styleFilter || styleFilter.length === 0) return true;
        return styleFilter.includes(prop);
      };

      for (let i = 0; i < computedStyles.length; i++) {
        const prop = computedStyles[i];
        if (!shouldIncludeStyle(prop)) continue;

        const value = computedStyles.getPropertyValue(prop);
        const convertedValue = rgbToHexFunc(value);
        computedStylesObj[prop] = convertedValue;
        output.push(`${prop}: ${convertedValue}`);
      }
      output.push('');

      // Inline styles
      output.push('=== INLINE STYLES ===');
      const inlineStylesObj: Record<string, string> = {};
      const htmlElement = element as HTMLElement;

      if (htmlElement.style.length > 0) {
        for (let i = 0; i < htmlElement.style.length; i++) {
          const prop = htmlElement.style[i];
          if (!shouldIncludeStyle(prop)) continue;

          const value = htmlElement.style.getPropertyValue(prop);
          const convertedValue = rgbToHexFunc(value);
          inlineStylesObj[prop] = convertedValue;
          output.push(`${prop}: ${convertedValue}`);
        }
      } else {
        output.push('No inline styles');
      }
      output.push('');

      return {
        elementInfo: {
          tag: element.tagName,
          id: element.id || 'none',
          classes: element.className || 'none',
        },
        html: element.outerHTML,
        computedStyles: computedStylesObj,
        inlineStyles: inlineStylesObj,
        formattedOutput: output.join('\n'),
      };
    }, selector, rgbToHex.toString(), selectiveStyles, options?.deepSearch ?? false);

    // Optionally save to file
    if (options?.outputFile) {
      const fs = await import('fs/promises');
      await fs.writeFile(options.outputFile, result.formattedOutput, 'utf-8');
      console.log(`âœ… Styles saved to ${options.outputFile}`);
    }

    // Optionally take screenshot
    if (options?.screenshotPath) {
      await page.screenshot({ path: options.screenshotPath as `${string}.png` | `${string}.jpeg` | `${string}.webp`, fullPage: true });
      console.log(`âœ… Screenshot saved to ${options.screenshotPath}`);
    }

    // Optionally generate PDF of the extracted styles
    if (options?.pdfPath) {
      // Create an HTML page with the extracted styles
      const htmlContent = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    body {
      font-family: 'Courier New', monospace;
      padding: 40px;
      line-height: 1.6;
      color: #333;
    }
    h2 {
      color: #2c3e50;
      border-bottom: 2px solid #3498db;
      padding-bottom: 10px;
    }
    pre {
      background-color: #f8f9fa;
      padding: 15px;
      border-radius: 5px;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
  </style>
</head>
<body>
  <pre>${result.formattedOutput.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>
</body>
</html>
      `;

      await page.setContent(htmlContent);
      await page.pdf({ path: options.pdfPath as `${string}.pdf`, format: 'A4', printBackground: true });
      console.log(`âœ… PDF saved to ${options.pdfPath}`);
    }

    console.log('âœ… Element styles extracted successfully!');
    console.log('\nPreview:');
    console.log(result.formattedOutput);

    return result;
  } finally {
    await browser.close();
  }
}

// CLI usage example
if (require.main === module) {
  const args = process.argv.slice(2);

  if (args.length < 2) {
    console.log('Usage: ts-node getStyling.ts <url> <selector> [outputFile] [--headful] [--screenshot=path] [--pdf=path] [--selective] [--stylelist=path] [--deep-search]');
    console.log('Example: ts-node getStyling.ts https://example.com "div.header" output.txt');
    console.log('Example: ts-node getStyling.ts https://example.com "div.header" output.txt --headful');
    console.log('Example: ts-node getStyling.ts https://example.com "div.header" output.txt --screenshot=page.png');
    console.log('Example: ts-node getStyling.ts https://example.com "div.header" output.txt --pdf=page.pdf');
    console.log('Example: ts-node getStyling.ts https://example.com "div.header" output.txt --selective');
    console.log('Example: ts-node getStyling.ts https://example.com "div.header" output.txt --selective --stylelist=mystyles.txt');
    console.log('Example: ts-node getStyling.ts https://example.com "button.submit" output.txt --deep-search');
    process.exit(1);
  }

  const headful = args.includes('--headful');
  const selective = args.includes('--selective');
  const deepSearch = args.includes('--deep-search');
  const screenshotArg = args.find(arg => arg.startsWith('--screenshot='));
  const screenshotPath = screenshotArg ? screenshotArg.split('=')[1] : undefined;
  const pdfArg = args.find(arg => arg.startsWith('--pdf='));
  const pdfPath = pdfArg ? pdfArg.split('=')[1] : undefined;
  const styleListArg = args.find(arg => arg.startsWith('--stylelist='));
  const styleListFile = styleListArg ? styleListArg.split('=')[1] : undefined;
  const filteredArgs = args.filter(arg =>
    arg !== '--headful' &&
    arg !== '--selective' &&
    arg !== '--deep-search' &&
    !arg.startsWith('--screenshot=') &&
    !arg.startsWith('--pdf=') &&
    !arg.startsWith('--stylelist=')
  );
  const [url, selector, outputFile] = filteredArgs;

  extractElementStyles(url, selector, {
    outputFile,
    headless: !headful,
    screenshotPath,
    pdfPath,
    selective,
    styleListFile,
    deepSearch
  })
    .then(() => process.exit(0))
    .catch((error) => {
      console.error('Error:', error.message);
      process.exit(1);
    });
}
